<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
    <head><link rel="stylesheet" type="text/css" href="description/Combined.css,0:HeaderFooterSprite,0:Header.NonMtps,1:LinkList;/Areas/Centers/Themes/StandardDevCenter/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=C9973DA951AE6202C9B348379A1BE49D" xmlns="http://www.w3.org/1999/xhtml" />
<link type="text/css" rel="stylesheet" xmlns="http://www.w3.org/1999/xhtml" />
<link rel="stylesheet" type="text/css" href="description/0aac1760-b513-488a-ba57-e31d9413a075Combined.css,0:HeaderFooterSprite,0:Footer.NonMtps,1:LinkList;/Areas/Centers/Themes/StandardDevCenter/Content:0,/Areas/Epx/Themes/Base/Content:1&amp;amp;hashKey=F576C687BC536B84D6E5B3246EE39B49" xmlns="http://www.w3.org/1999/xhtml" />
<link type="text/css" rel="stylesheet" xmlns="http://www.w3.org/1999/xhtml" />

        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title>Image Boundary Extraction</title>
        <link href="description/Galleries.css" type="text/css" rel="Stylesheet" /><link href="description/Layout.css" type="text/css" rel="Stylesheet" /><link href="description/Brand.css" type="text/css" rel="Stylesheet" />
        <link href="description/iframedescription.css" rel="Stylesheet" type="text/css" />
        <script src="description/offline.js" type="text/javascript"></script>
        <style type="text/css">
            #projectInfo {
                overflow: auto;
            }
            #longDesc {
                clear:both;
                margin: 25px 0 10px 0;
            }

            #SampleIndexList{
                margin-left: 15px;
            }
        </style>
    </head>
<body>
    <div id="offlineDescription">
        <h1>Image Boundary Extraction</h1>
        <br/>
        <div id="projectInfo">
            <div class="section">
                    <div class="itemBarLong tagsContainer">
                        <label for="Technologies">Technologies</label>
                        <div id="Technologies">
                            C#, .NET, Class Library, User Interface, Windows Forms, .NET Framework 4, .NET Framework 3.5 SP1, .NET Framework, .NET Framework 4.0, Image manipulation, Windows General, Windows UI, C# Language, WinForms, System.Media Namespace, .NET Framework 4.5, .NET Framwork, Graphics Functions, System.Drawing.<wbr />Drawing2D, Image process, Filter expression, Manipulation, Transformation, .NET 4.5, Computer Vision, .NET Development, Edge Detection, Windows Desktop App Development, Image Processing, Digital Signal Processing, Image Transformation, Image Software
                        </div>
                    </div>
                    <div class="itemBarLong tagsContainer">
                        <label for="Topics">Topics</label>
                        <div id="Topics">
                            Controls, Graphics, C#, GDI+, Class Library, Windows Forms, Graphics and 3D, Images, GeometryDrawing<wbr />, ImageViewer, Windows Form Controls, 2d graphics, Extensibility, Visual How To, Image manipulation, Code Sample, Image, Imaging, Drawing, How to, Generic C# resuable code, Image Optimization, general, Windows Forms Controls, C# Language Features, Language Sample, Graphics Functions, System.Drawing.<wbr />Drawing2D, .Net Programming, BitmapImage, Load Image, Dynamically Image, Extension methods, image rendering, Edge Detection, Line Detection, Image Filters, Image Convolution, Image Transformation, graphic rendering
                        </div>
                    </div>
                <div class="itemBarLong">
                    <label for="Platforms">Platforms</label>
                    <div id="Platforms">
                        Desktop, Web, Cloud, Phone, Data, Windows RT
                    </div>
                </div>
                <div class="itemBarLong">
                    <label for="Requirements">Requirements</label>
                    <div id="Requirements">
                        
                    </div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Primary language</label>
                    <div id="LastUpdated">en-US</div>
                </div>
                <div class="itemBar">
                    <label for="LastUpdated">Updated</label>
                    <div id="LastUpdated">8/9/2013</div>
                </div>
                <div class="itemBarLong">
                    <label for="License">License</label>
                    <div id="License">
                        <a href="license.rtf">MS-LPL</a></div>
                </div>
                <div class="itemBar">
                    <div class="viewonlinecont">
                        <a data-link="online" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad">View this sample online</a>
                    </div>
                </div>
            </div>
        </div>
        
                   
<script type="text/javascript">
    function initializePage() {
        var otherTabClass = 'otherTab';
        var hiddenPreClass = 'hidden';

        var htmlDecode = function(encodedData) {
            var decodedData = "";
            if (encodedData) {
                var div = document.createElement('div');
                div.innerHTML = encodedData;
                decodedData = div.firstChild.nodeValue.replace( /\\r\\n/ig , '\r\n');
            }
            return decodedData;
        };
                
        Galleries.iterateElem(Galleries.findElem(null, 'div', 'scriptcode'), function (index, scriptBlock) {
            var titleElem = Galleries.findElem(scriptBlock, 'div', 'title')[0];
            var labelElems = Galleries.findElem(titleElem, 'span');
            if (labelElems.length == 0) {
                labelElems = titleElem;
            }
            var languageSpans = Galleries.findElem(scriptBlock, 'span', 'hidden');
            var pres = Galleries.findElem(scriptBlock, 'pre');
            if (languageSpans.length > 0 && pres.length > 1) {
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    var languageSpan = languageSpans[index];
                            
                    elem.code = codePre.innerHTML.replace( /(\r(\n)?)|((\r)?\n)/ig , '\\r\\n');
                            
                    codePre.className = codePre.className.replace(hiddenPreClass, '');
                            
                    languageSpan.parentNode.removeChild(languageSpan);
                });

                pres = Galleries.findElem(scriptBlock, 'pre');
                Galleries.iterateElem(labelElems, function(index, elem) {
                    var codePre = pres[index];
                    var labelSpan = elem;
                    if (index == 0) {
                        scriptBlock.activeTab = 0;
                    }
                    else {
                        labelSpan.className += otherTabClass;
                        codePre.className += hiddenPreClass;
                    }
                    Galleries.attachEventHandler(labelSpan, 'click', function(e) {
                        var activeTab = scriptBlock.activeTab;
                        labelElems[activeTab].className += otherTabClass;
                        pres[activeTab].className += hiddenPreClass;

                        codePre.className = codePre.className.replace(hiddenPreClass, '');
                        labelSpan.className = labelSpan.className.replace(otherTabClass, '');
                        scriptBlock.activeTab = index;
                    });
                });

                var preview = Galleries.findElem(scriptBlock, 'div', 'preview');
                if (preview.length == 0) {
                    preview.push(pres[pres.length - 1]);
                }
                Galleries.iterateElem(preview, function(index, elem) {
                    elem.parentNode.removeChild(elem);
                });

                if (window.clipboardData && clipboardData.setData) {
                    var copyLink = document.createElement('a');
                    copyLink.href = 'javascript:void(0);';
                    copyLink.className = 'copyCode';
                    copyLink.innerHTML = 'Copy code';
                    Galleries.attachEventHandler(copyLink, 'click', function (e) {
                        clipboardData.setData("Text", htmlDecode(labelElems[scriptBlock.activeTab].code));
                        return false;
                    });
                    scriptBlock.insertBefore(copyLink, scriptBlock.childNodes[0]);
                }
            }
        });
    }

    Galleries.onWindowLoad(function(){
        initializePage();
    });

</script>
<div id="longDesc">
    
<h1>Introduction</h1>
<p style="text-align:justify">This article explores various <a title="Wikipedia: Image Processing" rel="tag" href="http://en.wikipedia.org/wiki/Image_processing" >
image processing</a> concepts, which feature in combination when implementing <strong>
<em>Image Boundary Extraction</em></strong>. Concepts covered within this article include: Morphological
<a title="Wikipedia: Image Erosion" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
Image Erosion</a> and <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
Image Dilation</a>, <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
Image</a> <strong><em>Addition</em></strong> and <strong><em>Subtraction</em></strong>,
<strong><em>Boundary Sharpening,</em></strong> <strong><em>Boundary Tracing</em></strong> and
<strong><em>Boundary Extraction.</em></strong></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94192" src="description/Parrot4_Boundary_Extraction_3x3_RGB.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Building the Sample</h1>
<p>There are&nbsp;no special requirements or instructions for building the sample source code.</p>
<h1>Using the Sample Application</h1>
<p style="text-align:justify">This article&rsquo;s accompanying sample source code includes the definition of a sample application. The sample application serves as an implementation of the concepts discussed in this article. In using the sample application
 concepts can be easily tested and replicated.</p>
<p style="text-align:justify">The sample application has been defined as a <a title="Windows Forms" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.windows.forms.form.aspx" >
Windows Forms application</a>. The user interface enables the user to configure several options which influence the output produced from
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> filtering processes. The following section describes the options available to a user when executing the sample application:</p>
<ul style="text-align:justify">
<li>
<p><strong><em>Loading and Saving files &ndash;</em></strong> Users can specify source/input
<a title="images" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
images</a> through clicking the <strong><em>Load Image</em></strong> button. If desired, resulting filtered
<a title="images" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
images</a> can be saved to the local <a title="System.IO.File" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.io.file.aspx" >
file</a> system when clicking the <strong><em>Save Image</em></strong> button.</p>
</li><li>
<p><strong><em>Filter Type &ndash;</em></strong> The types of filters implemented represent variations on
<strong><em>Image Boundary Extraction</em></strong>. The supported filter types are:
<strong><em>Conventional Boundary extraction</em></strong>, <strong><em>Boundary Sharpening</em></strong> and
<strong><em>Boundary Tracing</em></strong>.</p>
</li><li>
<p><strong><em>Filter Size &ndash;</em></strong> Filter intensity/strength will mostly be reliant on the filter size implemented. A Filter size represents the number of neighbouring
<a title="Wikipedia: Pixel" rel="tag" href="http://en.wikipedia.org/wiki/Pixel" >
pixels</a> examined when applying filters.</p>
</li><li>
<p><strong><em>Colours Applied &ndash;</em></strong> The sample source code and sample application provides functionality allowing a filter to only effect user specified colour components. Colour components are represented in the form of an
<strong><em>RGB</em></strong> <strong><em>colour scheme</em></strong>. The inclusion or exclusion of the colour components
<strong><em>Red</em></strong>, <strong><em>Green</em></strong> and <strong><em>Blue</em></strong> will be determined through user configuration.</p>
</li><li>
<p><strong><em>Structuring Element &ndash;</em></strong> As mentioned, the <strong>
<em>Filter Size</em></strong> option determines the size of neighbourhood <a title="Wikipedia: Pixel" rel="tag" href="http://en.wikipedia.org/wiki/Pixel" >
pixels</a> examined. The <a title="Structuring Element" rel="tag" href="http://en.wikipedia.org/wiki/Structuring_element" >
Structuring Element</a>&rsquo;s setup determine the neighbouring <a title="Wikipedia: Pixel" rel="tag" href="http://en.wikipedia.org/wiki/Pixel" >
pixels</a>&nbsp; within the <a title="Wikipedia: Pixel" rel="tag" href="http://en.wikipedia.org/wiki/Pixel" >
pixel</a> neighbourhood size bounds that should be used as input when calculating filter results.</p>
</li></ul>
<p style="text-align:justify">The following <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> is a screenshot of the <strong><em>Image Boundary Extraction</em></strong> sample application in action:</p>
<p><img id="94193" src="description/ImageBoundaryExtaction_Sample_Application.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Green</em></strong></p>
<p><img id="94194" src="description/Parrot2_Boundary_Extraction_3x3_G.jpg" alt="" width="500" height="332" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Morphological Boundary Extraction</h1>
<p style="text-align:justify"><strong><em>Image Boundary Extraction</em></strong> can be considered a method of
<a title="Wikipedia: Edge Detection" rel="tag" href="http://en.wikipedia.org/wiki/Edge_detection" >
Image Edge Detection</a>. In contrast to more commonly implemented <a title="Gradient Based" rel="tag" href="http://en.wikipedia.org/wiki/Image_gradient" >
gradient based</a>&nbsp;<a title="Wikipedia: Edge detection" rel="tag" href="http://en.wikipedia.org/wiki/Edge_detection" >edge detection</a> methods,
<strong><em>Image Boundary Extraction</em></strong> originates from <strong><em>Morphological Image Filters</em></strong>.</p>
<p style="text-align:justify">When drawing a comparison, <em><strong>Image Boundary Extraction</strong></em> and
<a title="Morphological Edge Detection" rel="tag" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/Morphological_Gradient" >
Morphological Edge Detection</a> express strong similarities. <a title="Morphological Edge Detection" rel="tag" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/Morphological_Gradient" >
Morphological Edge Detection</a> results from the difference in <a title="Wikipedia: Image Erosion" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
image erosion</a> and <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a>. Considered from a different point of view, creating one <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> expressing thicker edges and another <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> expressing thinner edges provides the means to calculate the difference in edges.</p>
<p style="text-align:justify"><strong><em>Image Boundary Extraction</em></strong> implements the same concept as
<a title="Morphological Edge Detection" rel="tag" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/Morphological_Gradient" >
Morphological Edge Detection</a>. The base concept can be regarded as calculating the difference between two
<a title="images" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
images</a> which rendered the same <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>, but expressing a difference in <a title="Image Edges" rel="tag" href="http://en.wikipedia.org/wiki/Edge_detection" >
image edges</a>. <strong><em>Image Boundary Extraction</em></strong> relies on calculating the difference between either
<a title="Wikipedia: Image Erosion" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
image erosion</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> or <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>. The difference between <a title="Wikipedia: Image Erosion" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
image erosion</a> and <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> in most cases result in more of difference than the difference between
<a title="Wikipedia: Image Erosion" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
image erosion</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> or <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>. The result of <strong><em>Image Boundary Extraction</em></strong> representing less of a difference than
<a title="Morphological Edge Detection" rel="tag" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/Morphological_Gradient" >
Morphological Edge Detection</a> can be observed in <strong><em>Image Boundary Extraction</em></strong> being expressed in finer/smaller width lines.</p>
<p style="text-align:justify"><a title="Wikipedia: Difference of Gaussians" rel="tag" href="http://en.wikipedia.org/wiki/Difference_of_Gaussians" >Difference of Gaussians</a> is another method of
<a title="Wikipedia: Edge detection" rel="tag" href="http://en.wikipedia.org/wiki/Edge_detection" >
edge detection</a> which functions along the same basis. Edges are determined by calculating the difference between two
<a title="images" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
images</a>, each having been filtered from the same source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>, using a <a title="Gaussian blur" rel="tag" href="http://en.wikipedia.org/wiki/Gaussian_blur" >
Gaussian blur</a> of differing intensity levels.</p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94195" src="description/Parrot1_Boundary_Extraction_3x3_RGB.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Boundary Sharpening</h1>
<p style="text-align:justify">The concept of <strong><em>Boundary Sharpening</em></strong> refers to enhancing or sharpening the boundaries or edges expressed in a source/input
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>. Boundaries can be easily determined or extracted as discussed earlier when exploring
<strong><em>Boundary Extraction</em></strong>.</p>
<p style="text-align:justify">The steps involved in performing <em><strong>Boundary Sharpening</strong></em> can be described as follows:</p>
<ol>
<li style="text-align:justify">
<p><strong><em>Extract Boundaries &ndash;</em></strong> Determine boundaries by performing
<a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> and calculating the difference between the dilated <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
</li><li style="text-align:justify">
<p><strong><em>Match Source Edges and Extracted Boundaries &ndash;</em></strong> The boundaries extracted in the previous step represent the difference between
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> <a title="Wikipedia: Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
dilation</a> and the original source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>. Ensure that extracted boundaries match the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> through performing <a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> on a copy of the source/input <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
</li><li>
<p style="text-align:justify"><strong><em>Emphasise Extracted boundaries in source image &ndash;</em></strong> Perform
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> addition using the extracted boundaries <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> and dilated copy of the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
</li></ol>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94196" src="description/Parrot3_Boundary_Extraction_3x3_RGB.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Boundary Tracing</h1>
<p style="text-align:justify"><strong><em>Boundary Tracing</em></strong> refers to applying
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> filters which result in <a title="Image Edges" rel="tag" href="http://en.wikipedia.org/wiki/Edge_detection" >
image edges</a>/boundaries appearing darker or more pronounced. This type of filter also relies on
<strong><em>Boundary Extraction</em></strong>.</p>
<p style="text-align:justify"><strong><em>Boundary Tracing</em></strong> can be implemented in two steps, described as follows:</p>
<ol>
<li style="text-align:justify">
<p><strong><em>Extract Boundaries &ndash;</em></strong> Determine boundaries by performing
<a title="Wikipedia: Image Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
image dilation</a> and calculating the difference between the dilated <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> and the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
</li><li>
<p style="text-align:justify"><strong><em>Emphasise Extracted boundaries in source image &ndash;</em></strong> Subtract the extracted boundaries from the original source
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
</li></ol>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94197" src="description/Parrot5_Boundary_Extraction_3x3_RGB.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Morphological Erosion and Dilation</h1>
<p style="text-align:justify">The accompanying sample source code defines the <strong>
<em>MorphologyOperation</em></strong> method,&nbsp; defined as an <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> targeting the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. In terms of parameters this method expects a two dimensional array representing a
<a title="Structuring Element" rel="tag" href="http://en.wikipedia.org/wiki/Structuring_element" >
structuring element</a>. The other required&nbsp; parameter represents an <a title="Enum" rel="tag" href="http://msdn.microsoft.com/en-us/library/sbbt4032(v=vs.110).aspx" >
enumeration</a> value indicating which <strong><em>Morphological Operation</em></strong> to perform, either
<a title="Erosion Morphology" rel="tag" href="http://en.wikipedia.org/wiki/Erosion_(morphology)" >
erosion</a> or <a title="Wikipedia: Dilation" rel="tag" href="http://en.wikipedia.org/wiki/Dilation_(morphology)" >
dilation</a>.</p>
<p style="text-align:justify">The following code snippet provides the definition in full:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap MorphologyOperation(this Bitmap sourceBitmap,
                                          bool[,] se,
                                          MorphologyOperationType morphType,
                                          bool applyBlue = true,
                                          bool applyGreen = true,
                                          bool applyRed = true)
{ 
    BitmapData sourceData =
               sourceBitmap.LockBits(new Rectangle(0, 0,
               sourceBitmap.Width, sourceBitmap.Height),
               ImageLockMode.ReadOnly,
               PixelFormat.Format32bppArgb);

    byte[] pixelBuffer = new byte[sourceData.Stride *
                                  sourceData.Height];

    byte[] resultBuffer = new byte[sourceData.Stride *
                                   sourceData.Height];

    Marshal.Copy(sourceData.Scan0, pixelBuffer, 0,
                               pixelBuffer.Length);

    sourceBitmap.UnlockBits(sourceData);

    int filterOffset = (se.GetLength(0) - 1) / 2;
    int calcOffset = 0, byteOffset = 0;
    byte blueErode = 0, greenErode = 0, redErode = 0;
    byte blueDilate = 0, greenDilate = 0, redDilate = 0;

    for (int offsetY = 0; offsetY &lt;
        sourceBitmap.Height - filterOffset; offsetY&#43;&#43;)
    {
        for (int offsetX = 0; offsetX &lt;
            sourceBitmap.Width - filterOffset; offsetX&#43;&#43;)
        {
            byteOffset = offsetY * sourceData.Stride &#43;
                         offsetX * 4;

            blueErode = 255; greenErode = 255; redErode = 255;
            blueDilate = 0; greenDilate = 0; redDilate = 0;

            for (int filterY = -filterOffset;
                    filterY &lt;= filterOffset; filterY&#43;&#43;)
            {
                for (int filterX = -filterOffset;
                    filterX &lt;= filterOffset; filterX&#43;&#43;)
                {
                    if (se[filterY &#43; filterOffset,  
                           filterX &#43; filterOffset] == true)
                    {
                        calcOffset = byteOffset &#43;
                                     (filterX * 4) &#43;
                        (filterY * sourceData.Stride);

                        calcOffset = (calcOffset &lt; 0 ? 0 :
                        (calcOffset &gt;= pixelBuffer.Length &#43; 2 ?
                        pixelBuffer.Length - 3 : calcOffset));

                        blueDilate =  
                        (pixelBuffer[calcOffset] &gt; blueDilate ?
                        pixelBuffer[calcOffset] : blueDilate);

                        greenDilate =  
                        (pixelBuffer[calcOffset &#43; 1] &gt; greenDilate ?
                        pixelBuffer[calcOffset &#43; 1] : greenDilate);

                        redDilate =  
                        (pixelBuffer[calcOffset &#43; 2] &gt; redDilate ?
                        pixelBuffer[calcOffset &#43; 2] : redDilate);

                        blueErode =  
                        (pixelBuffer[calcOffset] &lt; blueErode ?
                        pixelBuffer[calcOffset] : blueErode);

                        greenErode =  
                        (pixelBuffer[calcOffset &#43; 1] &lt; greenErode ?
                        pixelBuffer[calcOffset &#43; 1] : greenErode);

                        redErode =  
                        (pixelBuffer[calcOffset &#43; 2] &lt; redErode ?
                        pixelBuffer[calcOffset &#43; 2] : redErode);
                    }
                }
            }

            blueErode = (applyBlue ? blueErode : pixelBuffer[byteOffset]);
            blueDilate = (applyBlue ? blueDilate : pixelBuffer[byteOffset]);

            greenErode = (applyGreen ? greenErode : pixelBuffer[byteOffset &#43; 1]);
            greenDilate = (applyGreen ? greenDilate : pixelBuffer[byteOffset &#43; 1]);

            redErode = (applyRed ? redErode : pixelBuffer[byteOffset &#43; 2]);
            redDilate = (applyRed ? redDilate : pixelBuffer[byteOffset &#43; 2]);

            if (morphType == MorphologyOperationType.Erosion)
            {
                resultBuffer[byteOffset] = blueErode;
                resultBuffer[byteOffset &#43; 1] = greenErode;
                resultBuffer[byteOffset &#43; 2] = redErode;
            }
            else if (morphType == MorphologyOperationType.Dilation)
            {
                resultBuffer[byteOffset] = blueDilate;
                resultBuffer[byteOffset &#43; 1] = greenDilate;
                resultBuffer[byteOffset &#43; 2] = redDilate;
            }

            resultBuffer[byteOffset &#43; 3] = 255;
        }
    }

    Bitmap resultBitmap = new Bitmap(sourceBitmap.Width, sourceBitmap.Height);
    BitmapData resultData = resultBitmap.LockBits(new Rectangle(0, 0,
                            resultBitmap.Width, resultBitmap.Height),
                            ImageLockMode.WriteOnly,
                            PixelFormat.Format32bppArgb);

    Marshal.Copy(resultBuffer, 0, resultData.Scan0,
                               resultBuffer.Length);

    resultBitmap.UnlockBits(resultData);

    return resultBitmap;
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;MorphologyOperation(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>[,]&nbsp;se,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MorphologyOperationType&nbsp;morphType,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyBlue&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyGreen&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyRed&nbsp;=&nbsp;<span class="cs__keyword">true</span>)&nbsp;
{&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;sourceData&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Width,&nbsp;sourceBitmap.Height),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.ReadOnly,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;pixelBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[sourceData.Stride&nbsp;*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceData.Height];&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;resultBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[sourceData.Stride&nbsp;*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceData.Height];&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(sourceData.Scan0,&nbsp;pixelBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer.Length);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.UnlockBits(sourceData);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">int</span>&nbsp;filterOffset&nbsp;=&nbsp;(se.GetLength(<span class="cs__number">0</span>)&nbsp;-&nbsp;<span class="cs__number">1</span>)&nbsp;/&nbsp;<span class="cs__number">2</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">int</span>&nbsp;calcOffset&nbsp;=&nbsp;<span class="cs__number">0</span>,&nbsp;byteOffset&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>&nbsp;blueErode&nbsp;=&nbsp;<span class="cs__number">0</span>,&nbsp;greenErode&nbsp;=&nbsp;<span class="cs__number">0</span>,&nbsp;redErode&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>&nbsp;blueDilate&nbsp;=&nbsp;<span class="cs__number">0</span>,&nbsp;greenDilate&nbsp;=&nbsp;<span class="cs__number">0</span>,&nbsp;redDilate&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;offsetY&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;offsetY&nbsp;&lt;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Height&nbsp;-&nbsp;filterOffset;&nbsp;offsetY&#43;&#43;)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;offsetX&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;offsetX&nbsp;&lt;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Width&nbsp;-&nbsp;filterOffset;&nbsp;offsetX&#43;&#43;)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byteOffset&nbsp;=&nbsp;offsetY&nbsp;*&nbsp;sourceData.Stride&nbsp;&#43;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offsetX&nbsp;*&nbsp;<span class="cs__number">4</span>;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueErode&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;greenErode&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;redErode&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueDilate&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;greenDilate&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;redDilate&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;filterY&nbsp;=&nbsp;-filterOffset;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filterY&nbsp;&lt;=&nbsp;filterOffset;&nbsp;filterY&#43;&#43;)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;filterX&nbsp;=&nbsp;-filterOffset;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filterX&nbsp;&lt;=&nbsp;filterOffset;&nbsp;filterX&#43;&#43;)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">if</span>&nbsp;(se[filterY&nbsp;&#43;&nbsp;filterOffset,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filterX&nbsp;&#43;&nbsp;filterOffset]&nbsp;==&nbsp;<span class="cs__keyword">true</span>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcOffset&nbsp;=&nbsp;byteOffset&nbsp;&#43;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filterX&nbsp;*&nbsp;<span class="cs__number">4</span>)&nbsp;&#43;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(filterY&nbsp;*&nbsp;sourceData.Stride);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calcOffset&nbsp;=&nbsp;(calcOffset&nbsp;&lt;&nbsp;<span class="cs__number">0</span>&nbsp;?&nbsp;<span class="cs__number">0</span>&nbsp;:&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(calcOffset&nbsp;&gt;=&nbsp;pixelBuffer.Length&nbsp;&#43;&nbsp;<span class="cs__number">2</span>&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer.Length&nbsp;-&nbsp;<span class="cs__number">3</span>&nbsp;:&nbsp;calcOffset));&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueDilate&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset]&nbsp;&gt;&nbsp;blueDilate&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset]&nbsp;:&nbsp;blueDilate);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greenDilate&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;&gt;&nbsp;greenDilate&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;:&nbsp;greenDilate);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redDilate&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;&gt;&nbsp;redDilate&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;:&nbsp;redDilate);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueErode&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset]&nbsp;&lt;&nbsp;blueErode&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset]&nbsp;:&nbsp;blueErode);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greenErode&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;&lt;&nbsp;greenErode&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;:&nbsp;greenErode);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redErode&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;&lt;&nbsp;redErode&nbsp;?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pixelBuffer[calcOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;:&nbsp;redErode);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueErode&nbsp;=&nbsp;(applyBlue&nbsp;?&nbsp;blueErode&nbsp;:&nbsp;pixelBuffer[byteOffset]);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;blueDilate&nbsp;=&nbsp;(applyBlue&nbsp;?&nbsp;blueDilate&nbsp;:&nbsp;pixelBuffer[byteOffset]);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greenErode&nbsp;=&nbsp;(applyGreen&nbsp;?&nbsp;greenErode&nbsp;:&nbsp;pixelBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;greenDilate&nbsp;=&nbsp;(applyGreen&nbsp;?&nbsp;greenDilate&nbsp;:&nbsp;pixelBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redErode&nbsp;=&nbsp;(applyRed&nbsp;?&nbsp;redErode&nbsp;:&nbsp;pixelBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;redDilate&nbsp;=&nbsp;(applyRed&nbsp;?&nbsp;redDilate&nbsp;:&nbsp;pixelBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">if</span>&nbsp;(morphType&nbsp;==&nbsp;MorphologyOperationType.Erosion)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset]&nbsp;=&nbsp;blueErode;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;=&nbsp;greenErode;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;=&nbsp;redErode;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">else</span>&nbsp;<span class="cs__keyword">if</span>&nbsp;(morphType&nbsp;==&nbsp;MorphologyOperationType.Dilation)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset]&nbsp;=&nbsp;blueDilate;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;=&nbsp;greenDilate;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;=&nbsp;redDilate;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[byteOffset&nbsp;&#43;&nbsp;<span class="cs__number">3</span>]&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;Bitmap(sourceBitmap.Width,&nbsp;sourceBitmap.Height);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;resultData&nbsp;=&nbsp;resultBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.Width,&nbsp;resultBitmap.Height),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.WriteOnly,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(resultBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;resultData.Scan0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer.Length);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.UnlockBits(resultData);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;
}</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green</em></strong></p>
<p><img id="94198" src="description/Parrot1_Boundary_Extraction_3x3_RG.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Image Addition</h1>
<p style="text-align:justify">The sample source code encapsulates the process of combining two separate
<a title="images" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
images</a> through means of addition. The <strong><em>AddImage</em></strong> method serves as a single declaration of
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> addition functionality. This method has been defined as an <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> targeting the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. <strong><em>Boundary Sharpen</em></strong> filtering implements
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> addition.</p>
<p style="text-align:justify">The following code snippet provides the definition of the
<strong><em>AddImage</em></strong> <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a>:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap AddImage(this Bitmapsource Bitmap, 
                               Bitmap addBitmap)
{
    BitmapData sourceData =
               sourceBitmap.LockBits(new Rectangle (0, 0,
               sourceBitmap.Width, sourceBitmap.Height),
               ImageLockMode.ReadOnly,
               PixelFormat.Format32bppArgb);

    byte[] resultBuffer = new byte[sourceData.Stride *
                                  sourceData.Height];

    Marshal.Copy(sourceData.Scan0, resultBuffer, 0,
                               resultBuffer.Length);

    sourceBitmap.UnlockBits(sourceData);

    BitmapData addData =
               addBitmap.LockBits(new Rectangle(0, 0,
               addBitmap.Width, addBitmap.Height),
               ImageLockMode.ReadOnly,
               PixelFormat.Format32bppArgb);

    byte[] addBuffer = new byte[addData.Stride *
                                  addData.Height];

    Marshal.Copy(addData.Scan0, addBuffer, 0,
                               addBuffer.Length);

    addBitmap.UnlockBits(addData);

    for (int k = 0; k &#43; 4 &lt; resultBuffer.Length &amp;&amp;
                    k &#43; 4 &lt; addBuffer.Length; k &#43;= 4)
    {
        resultBuffer[k] =
        AddColors(resultBuffer[k], addBuffer[k]);
 
        resultBuffer[k &#43; 1] =
        AddColors(resultBuffer[k &#43; 1], addBuffer[k &#43; 1]);
 
        resultBuffer[k &#43; 2] =
        AddColors(resultBuffer[k &#43; 2], addBuffer[k &#43; 2]);
 
        resultBuffer[k &#43; 3] = 255;
    }

    Bitmap resultBitmap = new Bitmap(sourceBitmap.Width,
                                     sourceBitmap.Height);

    BitmapData resultData =
               resultBitmap.LockBits(new Rectangle(0, 0,
               resultBitmap.Width, resultBitmap.Height),
               ImageLockMode.WriteOnly,
               PixelFormat.Format32bppArgb);

    Marshal.Copy(resultBuffer, 0, resultData.Scan0,
                               resultBuffer.Length);

    resultBitmap.UnlockBits(resultData);

    return resultBitmap;
}

private static byte AddColors(byte color1, byte color2) 
{
    int result = color1 &#43; color2; 

    return (byte)(result &lt; 0 ? 0 : (result &gt; 255 ? 255 : result)); 
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;AddImage(<span class="cs__keyword">this</span>&nbsp;Bitmapsource&nbsp;Bitmap,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;addBitmap)&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;sourceData&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle&nbsp;(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Width,&nbsp;sourceBitmap.Height),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.ReadOnly,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;resultBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[sourceData.Stride&nbsp;*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceData.Height];&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(sourceData.Scan0,&nbsp;resultBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer.Length);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.UnlockBits(sourceData);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;addData&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBitmap.Width,&nbsp;addBitmap.Height),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.ReadOnly,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;addBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[addData.Stride&nbsp;*&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addData.Height];&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(addData.Scan0,&nbsp;addBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addBuffer.Length);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;addBitmap.UnlockBits(addData);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;k&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;k&nbsp;&#43;&nbsp;<span class="cs__number">4</span>&nbsp;&lt;&nbsp;resultBuffer.Length&nbsp;&amp;&amp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;&#43;&nbsp;<span class="cs__number">4</span>&nbsp;&lt;&nbsp;addBuffer.Length;&nbsp;k&nbsp;&#43;=&nbsp;<span class="cs__number">4</span>)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k]&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddColors(resultBuffer[k],&nbsp;addBuffer[k]);&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddColors(resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>],&nbsp;addBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]);&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddColors(resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>],&nbsp;addBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]);&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">3</span>]&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;Bitmap(sourceBitmap.Width,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Height);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;resultData&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.Width,&nbsp;resultBitmap.Height),&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.WriteOnly,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(resultBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;resultData.Scan0,&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer.Length);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.UnlockBits(resultData);&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;
}&nbsp;
&nbsp;
<span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;<span class="cs__keyword">byte</span>&nbsp;AddColors(<span class="cs__keyword">byte</span>&nbsp;color1,&nbsp;<span class="cs__keyword">byte</span>&nbsp;color2)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">int</span>&nbsp;result&nbsp;=&nbsp;color1&nbsp;&#43;&nbsp;color2;&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;(<span class="cs__keyword">byte</span>)(result&nbsp;&lt;&nbsp;<span class="cs__number">0</span>&nbsp;?&nbsp;<span class="cs__number">0</span>&nbsp;:&nbsp;(result&nbsp;&gt;&nbsp;<span class="cs__number">255</span>&nbsp;?&nbsp;<span class="cs__number">255</span>&nbsp;:&nbsp;result));&nbsp;&nbsp;
}</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94199" src="description/Parrot2_Boundary_Extraction_3x3_RGB.jpg" alt="" width="500" height="332" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Image Subtraction</h1>
<p style="text-align:justify">In a similar fashion regarding the <strong><em>AddImage</em></strong> method the sample code defines the
<strong><em>SubractImage</em></strong> method.&nbsp; By definition this method serves as an
<a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> targeting the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. <strong><em>Image subtraction</em></strong> has been implemented in
<strong><em>Boundary Extraction</em></strong> and <strong><em>Boundary Tracing</em></strong>.</p>
<p style="text-align:justify">The definition of the <strong><em>SubtractImage</em></strong> method listed as follows:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap SubtractImage(this Bitmap sourceBitmap,  
                                         Bitmap subtractBitmap) 
{
    BitmapData sourceData = 
               sourceBitmap.LockBits(new Rectangle(0, 0, 
               sourceBitmap.Width, sourceBitmap.Height), 
               ImageLockMode.ReadOnly, 
               PixelFormat.Format32bppArgb); 

    byte[] resultBuffer = new byte[sourceData.Stride * 
                                  sourceData.Height]; 

    Marshal.Copy(sourceData.Scan0, resultBuffer, 0, 
                               resultBuffer.Length); 

    sourceBitmap.UnlockBits(sourceData); 

    BitmapData subtractData = 
               subtractBitmap.LockBits(new Rectangle(0, 0, 
               subtractBitmap.Width, subtractBitmap.Height), 
               ImageLockMode.ReadOnly, 
               PixelFormat.Format32bppArgb); 

    byte[] subtractBuffer = new byte[subtractData.Stride * 
                                  subtractData.Height]; 

    Marshal.Copy(subtractData.Scan0, subtractBuffer, 0, 
                               subtractBuffer.Length); 

    subtractBitmap.UnlockBits(subtractData); 

    for (int  k = 0; k &#43; 4 &lt; resultBuffer.Length &amp;&amp;  
                    k &#43; 4 &lt; subtractBuffer.Length; k &#43;= 4) 
    { 
        resultBuffer[k] =  
        SubtractColors(resultBuffer[k], subtractBuffer[k]); 

        resultBuffer[k &#43; 1] =  
        SubtractColors(resultBuffer[k &#43; 1], subtractBuffer[k &#43; 1]); 

        resultBuffer[k &#43; 2] = 
        SubtractColors(resultBuffer[k &#43; 2], subtractBuffer[k &#43; 2]); 

        resultBuffer[k &#43; 3] = 255; 
    }

    Bitmap resultBitmap = new Bitmap (sourceBitmap.Width, 
                                     sourceBitmap.Height); 

    BitmapData resultData = 
               resultBitmap.LockBits(new Rectangle (0, 0, 
               resultBitmap.Width, resultBitmap.Height), 
               ImageLockMode.WriteOnly, 
               PixelFormat.Format32bppArgb); 

    Marshal.Copy(resultBuffer, 0, resultData.Scan0, 
                               resultBuffer.Length); 

    resultBitmap.UnlockBits(resultData); 

    return resultBitmap; 
}

private static byte SubtractColors(byte color1, byte color2) 
{
    int result = (int)color1 - (int)color2; 

    return (byte)(result &lt; 0 ? 0 : result); 
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;SubtractImage(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;subtractBitmap)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;sourceData&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Width,&nbsp;sourceBitmap.Height),&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.ReadOnly,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;resultBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[sourceData.Stride&nbsp;*&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceData.Height];&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(sourceData.Scan0,&nbsp;resultBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer.Length);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.UnlockBits(sourceData);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;subtractData&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtractBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtractBitmap.Width,&nbsp;subtractBitmap.Height),&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.ReadOnly,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">byte</span>[]&nbsp;subtractBuffer&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;<span class="cs__keyword">byte</span>[subtractData.Stride&nbsp;*&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtractData.Height];&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(subtractData.Scan0,&nbsp;subtractBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subtractBuffer.Length);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;subtractBitmap.UnlockBits(subtractData);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">for</span>&nbsp;(<span class="cs__keyword">int</span>&nbsp;&nbsp;k&nbsp;=&nbsp;<span class="cs__number">0</span>;&nbsp;k&nbsp;&#43;&nbsp;<span class="cs__number">4</span>&nbsp;&lt;&nbsp;resultBuffer.Length&nbsp;&amp;&amp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k&nbsp;&#43;&nbsp;<span class="cs__number">4</span>&nbsp;&lt;&nbsp;subtractBuffer.Length;&nbsp;k&nbsp;&#43;=&nbsp;<span class="cs__number">4</span>)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k]&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubtractColors(resultBuffer[k],&nbsp;subtractBuffer[k]);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubtractColors(resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>],&nbsp;subtractBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">1</span>]);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SubtractColors(resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>],&nbsp;subtractBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">2</span>]);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer[k&nbsp;&#43;&nbsp;<span class="cs__number">3</span>]&nbsp;=&nbsp;<span class="cs__number">255</span>;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;<span class="cs__keyword">new</span>&nbsp;Bitmap&nbsp;(sourceBitmap.Width,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.Height);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;BitmapData&nbsp;resultData&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.LockBits(<span class="cs__keyword">new</span>&nbsp;Rectangle&nbsp;(<span class="cs__number">0</span>,&nbsp;<span class="cs__number">0</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.Width,&nbsp;resultBitmap.Height),&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageLockMode.WriteOnly,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PixelFormat.Format32bppArgb);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Marshal.Copy(resultBuffer,&nbsp;<span class="cs__number">0</span>,&nbsp;resultData.Scan0,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBuffer.Length);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap.UnlockBits(resultData);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;&nbsp;
}&nbsp;
&nbsp;
<span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;<span class="cs__keyword">byte</span>&nbsp;SubtractColors(<span class="cs__keyword">byte</span>&nbsp;color1,&nbsp;<span class="cs__keyword">byte</span>&nbsp;color2)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">int</span>&nbsp;result&nbsp;=&nbsp;(<span class="cs__keyword">int</span>)color1&nbsp;-&nbsp;(<span class="cs__keyword">int</span>)color2;&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;(<span class="cs__keyword">byte</span>)(result&nbsp;&lt;&nbsp;<span class="cs__number">0</span>&nbsp;?&nbsp;<span class="cs__number">0</span>&nbsp;:&nbsp;result);&nbsp;&nbsp;
}</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Green</em></strong></p>
<p><img id="94200" src="description/Parrot5_Boundary_Extraction_3x3_G.jpg" alt="" width="500" height="331" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Image Boundary Extraction</h1>
<p style="text-align:justify">In the sample source code processing <strong><em>Image Boundary Extraction</em></strong> can be achieved when invoking the
<strong><em>BoundaryExtraction</em></strong> method. Defined as an <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a>, the <strong><em>BoundaryExtraction</em></strong> method targets the
<a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class.</p>
<p style="text-align:justify">As discussed earlier, this method performs <strong>
<em>Boundary Extraction</em></strong> through subtracting the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> from a dilated copy of the source <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>.</p>
<p style="text-align:justify">The following code snippet details the definition of the
<strong><em>BoundaryExtraction</em></strong> method:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap
BoundaryExtraction(this Bitmap sourceBitmap, 
                   bool[,] se, bool applyBlue = true, 
                   bool applyGreen = true, bool applyRed = true) 
{
    Bitmap resultBitmap = 
           sourceBitmap.MorphologyOperation(se,  
           MorphologyOperationType.Dilation, applyBlue,  
                                  applyGreen, applyRed); 

    resultBitmap = resultBitmap.SubtractImage(sourceBitmap); 
  
    return resultBitmap; 
} </pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;
BoundaryExtraction(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>[,]&nbsp;se,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyBlue&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyGreen&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyRed&nbsp;=&nbsp;<span class="cs__keyword">true</span>)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.MorphologyOperation(se,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MorphologyOperationType.Dilation,&nbsp;applyBlue,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;resultBitmap.SubtractImage(sourceBitmap);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;&nbsp;
}&nbsp;</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><em><strong>Parrot: Boundary Extraction, 3&times;3, Red, Blue</strong></em></p>
<p><img id="94201" src="description/Parrot5_Boundary_Extraction_3x3_RB.jpg" alt="" width="500" height="331" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Image Boundary Sharpening</h1>
<p style="text-align:justify"><strong><em>Boundary Sharpening</em></strong> in the sample source code has been implemented through the definition of the
<strong><em>BoundarySharpen</em></strong> method. The <strong><em>BoundarySharpen</em></strong>
<a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> targets the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. The following code snippet provides the definition:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap 
BoundarySharpen(this Bitmap sourceBitmap, 
                bool[,] se, bool applyBlue = true, 
                bool applyGreen = true, bool applyRed = true) 
{
    Bitmap resultBitmap = 
           sourceBitmap.BoundaryExtraction(se, applyBlue, 
                                           applyGreen, applyRed); 

    resultBitmap = sourceBitmap.MorphologyOperation(se,  
                   MorphologyOperationType.Dilation, applyBlue,  
                   applyGreen, applyRed).AddImage(resultBitmap); 

    return resultBitmap; 
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;&nbsp;
BoundarySharpen(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>[,]&nbsp;se,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyBlue&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyGreen&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyRed&nbsp;=&nbsp;<span class="cs__keyword">true</span>)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.BoundaryExtraction(se,&nbsp;applyBlue,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;sourceBitmap.MorphologyOperation(se,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MorphologyOperationType.Dilation,&nbsp;applyBlue,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed).AddImage(resultBitmap);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;&nbsp;
}</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Green</em></strong></p>
<p><img id="94203" src="description/Parrot4_Boundary_Extraction_3x3_G.jpg" alt="" width="500" height="446" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing Image Boundary Tracing</h1>
<p style="text-align:justify"><strong><em>Boundary Tracing</em></strong> has been defined through the
<strong><em>BoundaryTrace</em></strong> <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a>, which targets the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. Similar to the <strong><em>BoundarySharpen</em></strong> method this method performs
<strong><em>Boundary Extraction</em></strong>, the result of which serves to be subtracted from the original source
<a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a>. Subtracting <a title="Image" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.image.aspx" >
image</a> boundaries/edges result in those boundaries/edges being darkened, or traced. The definition of the
<strong><em>BoundaryTracing</em></strong> <a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> detailed as follows:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">private static Bitmap
BoundaryTrace(this Bitmap sourceBitmap, 
              bool[,] se, bool applyBlue = true, 
              bool applyGreen = true, bool applyRed = true) 
{
    Bitmap resultBitmap =
    sourceBitmap.BoundaryExtraction(se, applyBlue,  
                                    applyGreen, applyRed); 

    resultBitmap = sourceBitmap.SubtractImage(resultBitmap); 

    return resultBitmap; 
}</pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">private</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;
BoundaryTrace(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>[,]&nbsp;se,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyBlue&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyGreen&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyRed&nbsp;=&nbsp;<span class="cs__keyword">true</span>)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.BoundaryExtraction(se,&nbsp;applyBlue,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;sourceBitmap.SubtractImage(resultBitmap);&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;&nbsp;
}</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Green, Blue</em></strong></p>
<p><img id="94204" src="description/Parrot5_Boundary_Extraction_3x3_GB.jpg" alt="" width="500" height="331" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Implementing a Wrapper Method</h1>
<p style="text-align:justify">The <strong><em>BoundaryExtractionFilter</em></strong> method is the only method defined as publicly accessible. Following convention, this method&rsquo;s definition signals the method as an
<a title="MSDN: Extension Methods" rel="tag" href="http://msdn.microsoft.com/en-us/library/vstudio/bb383977.aspx" >
extension method</a> targeting the <a title="Bitmap" rel="tag" href="http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.aspx" >
Bitmap</a> class. This method has the intention of acting as a wrapper method, a single method capable of performing
<strong><em>Boundary Extraction</em></strong>, <strong><em>Boundary Sharpening</em></strong> and
<strong><em>Boundary Tracing</em></strong>, depending on method parameters.</p>
<p style="text-align:justify">The definition of the <strong><em>BoundaryExtractionFilter</em></strong> method detailed by the following code snippet:</p>
<p></p>
<div class="scriptcode">
<div class="pluginEditHolder" pluginCommand="mceScriptCode">
<div class="title"><span>C#</span></div>
<div class="pluginLinkHolder"><span class="pluginEditHolderLink">Edit</span>|<span class="pluginRemoveHolderLink">Remove</span></div>
<span class="hidden">csharp</span>
<pre class="hidden">public static Bitmap
BoundaryExtractionFilter(this Bitmap sourceBitmap, 
                         bool[,] se, BoundaryExtractionFilterType  
                         filterType, bool applyBlue = true, 
                         bool applyGreen = true, bool applyRed = true) 
{
    Bitmap resultBitmap = null; 

    if (filterType == BoundaryExtractionFilterType.BoundaryExtraction) 
    {
        resultBitmap =  
        sourceBitmap.BoundaryExtraction(se, applyBlue, 
                                        applyGreen, applyRed); 
    }
    else if (filterType == BoundaryExtractionFilterType.BoundarySharpen) 
    {
        resultBitmap =  
        sourceBitmap.BoundarySharpen(se, applyBlue,  
                                     applyGreen, applyRed); 
    }
    else if (filterType == BoundaryExtractionFilterType.BoundaryTrace) 
    {
        resultBitmap =  
        sourceBitmap.BoundaryTrace(se, applyBlue,  
                                   applyGreen, applyRed); 
    }
 
    return resultBitmap; 
} </pre>
<div class="preview">
<pre class="csharp"><span class="cs__keyword">public</span>&nbsp;<span class="cs__keyword">static</span>&nbsp;Bitmap&nbsp;
BoundaryExtractionFilter(<span class="cs__keyword">this</span>&nbsp;Bitmap&nbsp;sourceBitmap,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>[,]&nbsp;se,&nbsp;BoundaryExtractionFilterType&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filterType,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyBlue&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyGreen&nbsp;=&nbsp;<span class="cs__keyword">true</span>,&nbsp;<span class="cs__keyword">bool</span>&nbsp;applyRed&nbsp;=&nbsp;<span class="cs__keyword">true</span>)&nbsp;&nbsp;
{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;Bitmap&nbsp;resultBitmap&nbsp;=&nbsp;<span class="cs__keyword">null</span>;&nbsp;&nbsp;
&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">if</span>&nbsp;(filterType&nbsp;==&nbsp;BoundaryExtractionFilterType.BoundaryExtraction)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.BoundaryExtraction(se,&nbsp;applyBlue,&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">else</span>&nbsp;<span class="cs__keyword">if</span>&nbsp;(filterType&nbsp;==&nbsp;BoundaryExtractionFilterType.BoundarySharpen)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.BoundarySharpen(se,&nbsp;applyBlue,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">else</span>&nbsp;<span class="cs__keyword">if</span>&nbsp;(filterType&nbsp;==&nbsp;BoundaryExtractionFilterType.BoundaryTrace)&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultBitmap&nbsp;=&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sourceBitmap.BoundaryTrace(se,&nbsp;applyBlue,&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;applyGreen,&nbsp;applyRed);&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;<span class="cs__keyword">return</span>&nbsp;resultBitmap;&nbsp;&nbsp;
}&nbsp;</pre>
</div>
</div>
</div>
<p></p>
<p style="text-align:center"><strong><em>Parrot: Boundary Extraction, 3&times;3, Red, Green, Blue</em></strong></p>
<p><img id="94205" src="description/Parrot6_Boundary_Extraction_3x3_RGB.jpg" alt="" width="500" height="750" style="margin-right:auto; margin-left:auto; display:block"></p>
<h1>Sample Images</h1>
<p style="text-align:justify">This article features a number of sample images. All featured images have been licensed allowing for reproduction. The following images feature as sample images:</p>
<p><img id="94206" src="description/1280px-Ara_macao_-Diergaarde_Blijdorp_-flying-8a.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">Scarlet Macaw at Diergaarde Blijdorp, Rotterdam, Netherlands.
</li><li style="padding-left:30px"><strong>Attributed to: </strong><a title="flickr.com" href="http://flickr.com/photos/40803964@N08" >Jar0d</a>. This file is licensed under the
<a title="Creative Commons" href="http://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://creativecommons.org/licenses/by-sa/2.0/deed.en" >
Attribution-Share Alike 2.0 Generic</a> license. </li><li style="padding-left:30px"><a title="Wikipedia" href="http://en.wikipedia.org/wiki/File:Ara_macao_-Diergaarde_Blijdorp_-flying-8a.jpg" >Download from Wikipedia</a>
</li></div>
<p><img id="94207" src="description/Ara_macao_-flying_away-8a.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">A Scarlet Macaw flying away from the photographer. </li><li style="padding-left:30px"><strong>Attributed to: </strong>&nbsp;<a title="Creative Commons" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://de.wikipedia.org/wiki/User:Robert01" >Robert01</a>. This file is licensed under the
<a title="Creative Commons" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://creativecommons.org/licenses/by-sa/3.0/de/deed.en" >
Attribution-Share Alike 3.0 Germany</a> license. </li><li style="padding-left:30px"><a title="Wikipedia" href="http://code.msdn.microsoft.com/Image-Boundary-Extraction-c32b3fad/https://en.wikipedia.org/wiki/File:Ara_macao_-flying_away-8a.jpg" >Download from Wikipedia</a>
</li></div>
<p><img id="94208" src="description/Ara_ararauna_Luc_Viatour.jpg" alt="" width="500" height="386" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">Blue-and-yellow Macaw in flight. </li><li style="padding-left:30px"><strong>Attributed to: </strong><a title="Creative Commons" href="http://commons.wikimedia.org/wiki/User:Lviatour" >Luc Viatour</a> &ndash;
<a title="Luc Viatour / www.Lucnix.be" href="http://www.lucnix.be/" >
www.lucnix.be</a>. This file is licensed under the <a title="Creative Commons" href="http://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://creativecommons.org/licenses/by/2.0/deed.en" >
Attribution 2.0 Generic</a> license. </li><li style="padding-left:30px"><a title="Wikipedia" href="http://en.wikipedia.org/wiki/File:Ara_ararauna_Luc_Viatour.jpg" >Download from Wikipedia</a>&nbsp;
</li></div>
<p><img id="94209" src="description/1280px-Macaws_at_Seaport_Village_-USA-8a.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">Two Green-winged Macaws (also known as the Red-and-green Macaw) resting at Seaport Village, San Diego, USA.
</li><li style="padding-left:30px"><strong>Attributed to:</strong> <a title="flickr.com" href="http://www.flickr.com/people/9511824@N05" >
Dave Fayram</a><strong>.</strong> This file is licensed under the <a title="Creative Commons" href="http://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://creativecommons.org/licenses/by/2.0/deed.en" >
Attribution 2.0 Generic</a> license. </li><li style="padding-left:30px"><a title="Wikimedia.org" href="http://commons.wikimedia.org/wiki/File:Macaws_at_Seaport_Village_-USA-8a.jpg" >Download from Wikimedia.org</a>
</li></div>
<p><img id="94210" src="description/Ara_macao_-on_a_small_bicycle-8.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">A Scarlet Macaw riding a small tricycle at an exhibition in Spain.
</li><li style="padding-left:30px"><strong>Attributed to:</strong> <a title="flickr.com" href="http://www.flickr.com/people/28634469@N03" >
The Torch</a>. This file is licensed under the <a title="Creative Commons" href="http://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://creativecommons.org/licenses/by/2.0/deed.en" >
Attribution 2.0 Generic</a> license. </li><li style="padding-left:30px"><a title="Wikipedia" href="http://en.wikipedia.org/wiki/File:Ara_macao_-on_a_small_bicycle-8.jpg" >Download from Wikipedia</a>.
</li></div>
<p><img id="94211" src="description/Psarisomus_dalhousiae_-_Kaeng_Krachan.jpg" alt="" style="margin-right:auto; margin-left:auto; display:block"></p>
<div>
<li style="padding-left:30px">Long-tailed Broadbill (<em>Psarisomus dalhousiae</em>), Kaeng Krachan National Park, Phetchaburi, Thailand.
</li><li style="padding-left:30px"><strong>Attributed to</strong> <a title="User-JJ Harrison" href="http://commons.wikimedia.org/wiki/User:JJ_Harrison" >
User-JJ Harrison</a>. This file is licensed under the <a title="Creative Commons" href="http://en.wikipedia.org/wiki/en:Creative_Commons" >
Creative Commons</a> <a title="Creative Commons" href="http://creativecommons.org/licenses/by-sa/3.0/deed.en" >
Attribution-Share Alike 3.0 Unported</a> license. </li><li style="padding-left:30px"><a title="Wikipedia" href="http://en.wikipedia.org/wiki/File:Psarisomus_dalhousiae_-_Kaeng_Krachan.jpg" >Download from Wikipedia</a>.
</li></div>
<h1>Source Code Files</h1>
<ul>
<li><em>ExtBitmap.cs - Contains the following method definitions: BoundaryExtractionFilter, BoundaryExtraction, BoundarySharpen, BoundaryTrace, MorphologyOperation, SubtractImage, AddImage.</em>
</li><li><em><em>MainForm.cs - Windows Forms test application.</em></em> </li></ul>
<h1>More Information</h1>
<div>
<p style="text-align:justify">This article is based on an article originally posted on my
<a href="http://softwarebydefault.com/" >blog</a>: <a href="http://softwarebydefault.com/2013/07/21/image-boundary-extraction/">
http://softwarebydefault.com/2013/07/21/image-boundary-extraction/</a>&nbsp;If you have any questions/comments please feel free to make use of the Q&amp;A section on this page, also please remember to rate this article.</p>
<p><strong><em><a title="About Dewald Esterhuizen" rel="tag" href="http://softwarebydefault.com/about/" >Dewald Esterhuizen</a></em></strong></p>
</div>

</div>


    </div>
</body>
</html>
